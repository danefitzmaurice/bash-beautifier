{"id":"beautifier/format-instance-worker.ts","dependencies":[{"name":"/Users/danefitzmaurice/Projects/git-hub/bash-beautifier/lib/tsconfig.json","includedInParent":true,"mtime":1613730500902},{"name":"/Users/danefitzmaurice/Projects/git-hub/bash-beautifier/package.json","includedInParent":true,"mtime":1613730623060},{"name":"./snippet","loc":{"line":6,"column":24},"parent":"/Users/danefitzmaurice/Projects/git-hub/bash-beautifier/lib/beautifier/format-instance-worker.ts","resolved":"/Users/danefitzmaurice/Projects/git-hub/bash-beautifier/lib/beautifier/snippet.ts"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormatInstanceWorker = void 0;\nvar tslib_1 = require(\"tslib\");\nvar events_1 = require(\"events\");\nvar snippet_1 = require(\"./snippet\");\nvar HEREDOC_START_REGEX = /.*<<-?\\s*[\\'|\"]?([_|\\w]+)[\\'|\"]?.*/;\nvar FUNCTION_STYLE_REGEX = [\n    /\\bfunction\\s+(\\w*)\\s*\\(\\s*\\)\\s*/,\n    /\\bfunction\\s+(\\w*)\\s*/,\n    /\\b\\s*(\\w*)\\s*\\(\\s*\\)\\s*/\n];\nvar FUNCTION_STYLE_REPLACEMENT = [\n    /function \\g<1>() /,\n    /function \\g<1> /,\n    /\\g<1>() /\n];\n/**\n * Takes the given Bash source code line and simplifies it by removing stuff\n * that is not useful for the purpose of indentation level calculation.\n *\n * @param sourceLine ...\n * @returns ...\n */\nfunction getTestRecord(sourceLine) {\n    return (sourceLine\n        // collapse multiple quotes between ' ... '\n        .sub(/'.*?'/g, '')\n        // collapse multiple quotes between \" ... \"\n        .sub(/\".*?\"/g, '')\n        // collapse multiple quotes between ` ... `\n        .sub(/`.*?`/g, '')\n        // collapse multiple quotes between \\` ... ' (weird case)\n        .sub(/\\\\`.*?'`/g, '')\n        // strip out any escaped single characters\n        .sub(/\\\\./g, '')\n        // remove '#' comments\n        .sub(/(^|\\s)(#.*)/, '', 1));\n}\n/**\n * Returns the index for the function declaration style detected in the given\n * string or null if no function declarations are detected.\n *\n * @param testRecord ...\n * @returns ...\n */\nfunction detectFunctionStyle(testRecord) {\n    // IMPORTANT: apply regex sequentially and stop on the first match:\n    return (FUNCTION_STYLE_REGEX.findIndex(function (regex) { return regex.test(testRecord.src); }) ||\n        null);\n}\nvar FormatInstanceWorker = /** @class */ (function (_super) {\n    tslib_1.__extends(FormatInstanceWorker, _super);\n    function FormatInstanceWorker() {\n        var _this = _super.call(this) || this;\n        _this.indentSize = atom.config.get('shell-script-beautifier.indentSize');\n        _this.indentType = atom.config.get('shell-script-beautifier.indentType');\n        _this.backup = atom.config.get('shell-script-beautifier.backup');\n        // readonly applyFunctionStyle = atom.config.get('shell-script-beautifier.applyFunctionStyle');\n        _this.applyFunctionStyle = null;\n        _this.tab = 0;\n        _this.caseLevel = 0;\n        _this.continueLine = false;\n        _this.openBrackets = 0;\n        _this.inHereDoc = false;\n        _this.deferExtQuote = false;\n        _this.inExtQuote = false;\n        _this.extQuoteString = '';\n        _this.hereString = '';\n        _this.line = 1;\n        _this.formatter = true;\n        _this.lines = [];\n        _this.onLineEnd = function (strippedRecord, testRecord) {\n            // count open brackets for this.line continuation\n            _this.openBrackets += testRecord.occurrences(/\\[/g);\n            _this.openBrackets -= testRecord.occurrences(/\\]/g);\n            _this.continueLine = strippedRecord.contains(/\\\\$/g);\n            _this.line++;\n        };\n        _this.on('line-end', _this.onLineEnd);\n        return _this;\n    }\n    Object.defineProperty(FormatInstanceWorker.prototype, \"output\", {\n        get: function () {\n            return this.lines.join('\\n');\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FormatInstanceWorker.apply = function (data, path) {\n        if (path === void 0) { path = ''; }\n        var worker = new FormatInstanceWorker();\n        for (var _i = 0, _a = data.split('\\n'); _i < _a.length; _i++) {\n            var line = _a[_i];\n            worker.processLine(line);\n        }\n        if (worker.tab !== 0) {\n            console.error(\"File \" + path + \": error: indent/outdent mismatch: \" + worker.tab + \".\\n\");\n        }\n        return worker.output;\n    };\n    FormatInstanceWorker.prototype.processLine = function (input) {\n        //\n        var line = input.replace(/ +?$/, '');\n        //\n        var stripped = new snippet_1.Snippet(line.trim());\n        // preserve blank lines\n        if (!stripped.src) {\n            this.write(stripped.src);\n            console.log('outat', 1);\n            return;\n        }\n        // ensure space before ;; terminators in case statements\n        if (this.caseLevel) {\n            // stripped = utils.sub(r'(\\S);;', r'\\1 ;;', stripped)\n            stripped = stripped.replace(/(\\S);;/g, '\\\\1 ;;');\n        }\n        var test = getTestRecord(stripped);\n        // pass on with no changes\n        if (this.inHereDoc) {\n            this.write(line);\n            // now test for here-doc termination string\n            if (test.contains(this.hereString) && !test.contains(/<</)) {\n                this.inHereDoc = false;\n            }\n            return this.emit('line-end', stripped, test);\n        }\n        // not in here doc\n        if (test.contains(/<<-?/) && !test.contains(/done.*<<</)) {\n            this.hereString = stripped.sub(HEREDOC_START_REGEX, '\\\\1', 1).src;\n            this.inHereDoc = this.hereString.length > 0;\n        }\n        if (!this.inExtQuote && test.contains(/(^|\\s)(\\'|\")/g)) {\n            // apply only after this line has been processed\n            this.deferExtQuote = true;\n            this.extQuoteString = test.sub(/.*([\\'\"]).*/g, '\\\\1', 1).src;\n            // provide this.line before quote\n            test = test.sub(new RegExp(\"(.*)\" + this.extQuoteString + \"s.*\"), '\\\\1', 1);\n        }\n        if (this.inExtQuote && test.contains(this.extQuoteString)) {\n            // provide this.line after quotes\n            test = test.sub(new RegExp(\".*\" + this.extQuoteString + \"s(.*)\"), '\\\\1', 1);\n            this.inExtQuote = false;\n        }\n        if (this.inExtQuote || !this.formatter) {\n            // pass on unchanged\n            this.write(line);\n            if (stripped.contains(/#\\s*@this.formatter:on/g)) {\n                this.formatter = true;\n                return;\n            }\n            return this.emit('line-end', stripped, test);\n        }\n        // not in ext quote\n        if (stripped.contains(/#\\s*@this.formatter:off/g)) {\n            this.formatter = false;\n            this.write(line);\n            return;\n        }\n        // multi-this.line conditions are often meticulously formatted\n        if (this.openBrackets) {\n            this.write(line);\n            if (this.deferExtQuote) {\n                this.inExtQuote = true;\n                this.deferExtQuote = false;\n            }\n            return this.emit('line-end', stripped, test);\n        }\n        var inc = test.occurrences(/(\\s|^|;)(case|then|do)(;|$|\\s)/g);\n        inc += test.occurrences(/(\\{|\\(|\\[)/g);\n        var outc = test.occurrences(/(\\s|^|;)(esac|fi|done|elif)(;|\\)|\\||$|\\s)/g);\n        outc += test.occurrences(/(\\}|\\)|\\])/g);\n        if (test.contains(/\\besac\\b/g)) {\n            if (this.caseLevel == 0) {\n                throw new Error(\"File \" + path + \": error: \\\"esac\\\" before \\\"case\\\" in this.line \" + this.line + \".\\n\");\n            }\n            outc += 1;\n            this.caseLevel -= 1;\n        }\n        // special handling for bad syntax within case ... esac\n        if (test.contains(/\\bcase\\b/g)) {\n            inc += 1;\n            this.caseLevel += 1;\n        }\n        var choiceCase = 0;\n        if (this.caseLevel && test.contains(/^[^(]*\\)/g)) {\n            inc += 1;\n            choiceCase = -1;\n        }\n        // detect functions\n        var funcDeclStyle = detectFunctionStyle(test);\n        if (funcDeclStyle !== null) {\n            stripped = this.changeFunctionStyle(stripped, funcDeclStyle);\n        }\n        // an ad-hoc solution for the \"else\" keyword\n        var elseCase = !test.contains(/^(else|elif)/) ? 0 : -1;\n        var net = inc - outc;\n        this.tab += Math.min(net, 0);\n        // while 'tab' is preserved across multiple lines, 'extab' is not and is\n        // used for some adjustments:\n        var extab = this.tab + elseCase + choiceCase;\n        if (this.continueLine && !this.openBrackets) {\n            extab++;\n        }\n        extab = Math.max(0, extab);\n        this.write(this.indentType.repeat(this.indentSize * extab) + stripped);\n        this.tab += Math.max(net, 0);\n        if (this.deferExtQuote) {\n            this.inExtQuote = true;\n            this.deferExtQuote = false;\n        }\n        this.emit('line-end', stripped, test);\n    };\n    /**\n     * Converts a function definition syntax from the 'func_decl_style' to the one\n     * that has been set in self.apply_function_style and returns the string with\n     * the converted syntax.\n     *\n     * @param strippedRecord ...\n     * @param funcDeclStyle ...\n     * @returns ...\n     */\n    FormatInstanceWorker.prototype.changeFunctionStyle = function (strippedRecord, funcDeclStyle) {\n        if (funcDeclStyle === null)\n            return strippedRecord;\n        if (this.applyFunctionStyle === null) {\n            // user does not want to enforce any specific function style\n            return strippedRecord;\n        }\n        var regex = FUNCTION_STYLE_REGEX[funcDeclStyle];\n        var replacement = FUNCTION_STYLE_REPLACEMENT[this.applyFunctionStyle];\n        return strippedRecord.sub(regex, replacement).strip();\n    };\n    FormatInstanceWorker.prototype.write = function (data) {\n        this.lines.push(data);\n    };\n    return FormatInstanceWorker;\n}(events_1.EventEmitter));\nexports.FormatInstanceWorker = FormatInstanceWorker;\n"},"sourceMaps":{"js":{"version":3,"file":"format-instance-worker.js","sourceRoot":"","sources":["beautifier/format-instance-worker.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\n\nimport { Snippet } from './snippet';\n\nconst HEREDOC_START_REGEX = /.*<<-?\\s*[\\'|\"]?([_|\\w]+)[\\'|\"]?.*/;\n\nconst FUNCTION_STYLE_REGEX = [\n  /\\bfunction\\s+(\\w*)\\s*\\(\\s*\\)\\s*/,\n  /\\bfunction\\s+(\\w*)\\s*/,\n  /\\b\\s*(\\w*)\\s*\\(\\s*\\)\\s*/\n];\n\nconst FUNCTION_STYLE_REPLACEMENT = [\n  /function \\g<1>() /,\n  /function \\g<1> /,\n  /\\g<1>() /\n];\n\n/**\n * Takes the given Bash source code line and simplifies it by removing stuff\n * that is not useful for the purpose of indentation level calculation.\n *\n * @param sourceLine ...\n * @returns ...\n */\nfunction getTestRecord(sourceLine: Snippet) {\n  return (\n    sourceLine\n      // collapse multiple quotes between ' ... '\n      .sub(/'.*?'/g, '')\n      // collapse multiple quotes between \" ... \"\n      .sub(/\".*?\"/g, '')\n      // collapse multiple quotes between ` ... `\n      .sub(/`.*?`/g, '')\n      // collapse multiple quotes between \\` ... ' (weird case)\n      .sub(/\\\\`.*?'`/g, '')\n      // strip out any escaped single characters\n      .sub(/\\\\./g, '')\n      // remove '#' comments\n      .sub(/(^|\\s)(#.*)/, '', 1)\n  );\n}\n\n/**\n * Returns the index for the function declaration style detected in the given\n * string or null if no function declarations are detected.\n *\n * @param testRecord ...\n * @returns ...\n */\nfunction detectFunctionStyle(testRecord: Snippet) {\n  // IMPORTANT: apply regex sequentially and stop on the first match:\n  return (\n    FUNCTION_STYLE_REGEX.findIndex((regex) => regex.test(testRecord.src)) ||\n    null\n  );\n}\n\nexport class FormatInstanceWorker extends EventEmitter {\n  readonly indentSize = atom.config.get('shell-script-beautifier.indentSize');\n  readonly indentType = atom.config.get('shell-script-beautifier.indentType');\n  readonly backup = atom.config.get('shell-script-beautifier.backup');\n  // readonly applyFunctionStyle = atom.config.get('shell-script-beautifier.applyFunctionStyle');\n  readonly applyFunctionStyle: number | null = null;\n\n  tab = 0;\n  caseLevel = 0;\n  continueLine = false;\n  openBrackets = 0;\n  inHereDoc = false;\n  deferExtQuote = false;\n  inExtQuote = false;\n  extQuoteString = '';\n  hereString = '';\n  line = 1;\n  formatter = true;\n  lines: string[] = [];\n\n  get output() {\n    return this.lines.join('\\n');\n  }\n\n  constructor() {\n    super();\n\n    this.on('line-end', this.onLineEnd);\n  }\n\n  static apply(data: string, path = '') {\n    const worker = new FormatInstanceWorker();\n\n    for (let line of data.split('\\n')) {\n      worker.processLine(line);\n    }\n\n    if (worker.tab !== 0) {\n      console.error(\n        `File ${path}: error: indent/outdent mismatch: ${worker.tab}.\\n`\n      );\n    }\n\n    return worker.output;\n  }\n\n  processLine(input: string) {\n    //\n    const line = input.replace(/ +?$/, '');\n    //\n    let stripped = new Snippet(line.trim());\n\n    // preserve blank lines\n    if (!stripped.src) {\n      this.write(stripped.src);\n\n      console.log('outat', 1);\n\n      return;\n    }\n\n    // ensure space before ;; terminators in case statements\n    if (this.caseLevel) {\n      // stripped = utils.sub(r'(\\S);;', r'\\1 ;;', stripped)\n      stripped = stripped.replace(/(\\S);;/g, '\\\\1 ;;');\n    }\n\n    let test = getTestRecord(stripped);\n\n    // pass on with no changes\n    if (this.inHereDoc) {\n      this.write(line);\n\n      // now test for here-doc termination string\n      if (test.contains(this.hereString) && !test.contains(/<</)) {\n        this.inHereDoc = false;\n      }\n\n      return this.emit('line-end', stripped, test);\n    }\n\n    // not in here doc\n    if (test.contains(/<<-?/) && !test.contains(/done.*<<</)) {\n      this.hereString = stripped.sub(HEREDOC_START_REGEX, '\\\\1', 1).src;\n\n      this.inHereDoc = this.hereString.length > 0;\n    }\n\n    if (!this.inExtQuote && test.contains(/(^|\\s)(\\'|\")/g)) {\n      // apply only after this line has been processed\n      this.deferExtQuote = true;\n      this.extQuoteString = test.sub(/.*([\\'\"]).*/g, '\\\\1', 1).src;\n\n      // provide this.line before quote\n      test = test.sub(new RegExp(`(.*)${this.extQuoteString}s.*`), '\\\\1', 1);\n    }\n\n    if (this.inExtQuote && test.contains(this.extQuoteString)) {\n      // provide this.line after quotes\n      test = test.sub(new RegExp(`.*${this.extQuoteString}s(.*)`), '\\\\1', 1);\n\n      this.inExtQuote = false;\n    }\n\n    if (this.inExtQuote || !this.formatter) {\n      // pass on unchanged\n      this.write(line);\n\n      if (stripped.contains(/#\\s*@this.formatter:on/g)) {\n        this.formatter = true;\n        return;\n      }\n\n      return this.emit('line-end', stripped, test);\n    }\n\n    // not in ext quote\n    if (stripped.contains(/#\\s*@this.formatter:off/g)) {\n      this.formatter = false;\n      this.write(line);\n\n      return;\n    }\n\n    // multi-this.line conditions are often meticulously formatted\n\n    if (this.openBrackets) {\n      this.write(line);\n\n      if (this.deferExtQuote) {\n        this.inExtQuote = true;\n        this.deferExtQuote = false;\n      }\n\n      return this.emit('line-end', stripped, test);\n    }\n\n    let inc = test.occurrences(/(\\s|^|;)(case|then|do)(;|$|\\s)/g);\n    inc += test.occurrences(/(\\{|\\(|\\[)/g);\n\n    let outc = test.occurrences(/(\\s|^|;)(esac|fi|done|elif)(;|\\)|\\||$|\\s)/g);\n    outc += test.occurrences(/(\\}|\\)|\\])/g);\n\n    if (test.contains(/\\besac\\b/g)) {\n      if (this.caseLevel == 0) {\n        throw new Error(\n          `File ${path}: error: \"esac\" before \"case\" in this.line ${this.line}.\\n`\n        );\n      }\n\n      outc += 1;\n      this.caseLevel -= 1;\n    }\n\n    // special handling for bad syntax within case ... esac\n    if (test.contains(/\\bcase\\b/g)) {\n      inc += 1;\n      this.caseLevel += 1;\n    }\n\n    let choiceCase = 0;\n\n    if (this.caseLevel && test.contains(/^[^(]*\\)/g)) {\n      inc += 1;\n      choiceCase = -1;\n    }\n\n    // detect functions\n    const funcDeclStyle = detectFunctionStyle(test);\n\n    if (funcDeclStyle !== null) {\n      stripped = this.changeFunctionStyle(stripped, funcDeclStyle);\n    }\n\n    // an ad-hoc solution for the \"else\" keyword\n    let elseCase = !test.contains(/^(else|elif)/) ? 0 : -1;\n\n    let net = inc - outc;\n\n    this.tab += Math.min(net, 0);\n\n    // while 'tab' is preserved across multiple lines, 'extab' is not and is\n    // used for some adjustments:\n    let extab = this.tab + elseCase + choiceCase;\n\n    if (this.continueLine && !this.openBrackets) {\n      extab++;\n    }\n\n    extab = Math.max(0, extab);\n\n    this.write(this.indentType.repeat(this.indentSize * extab) + stripped);\n\n    this.tab += Math.max(net, 0);\n\n    if (this.deferExtQuote) {\n      this.inExtQuote = true;\n      this.deferExtQuote = false;\n    }\n\n    this.emit('line-end', stripped, test);\n  }\n\n  /**\n   * Converts a function definition syntax from the 'func_decl_style' to the one\n   * that has been set in self.apply_function_style and returns the string with\n   * the converted syntax.\n   *\n   * @param strippedRecord ...\n   * @param funcDeclStyle ...\n   * @returns ...\n   */\n  private changeFunctionStyle(strippedRecord: Snippet, funcDeclStyle: number) {\n    if (funcDeclStyle === null) return strippedRecord;\n\n    if (this.applyFunctionStyle === null) {\n      // user does not want to enforce any specific function style\n      return strippedRecord;\n    }\n\n    const regex = FUNCTION_STYLE_REGEX[funcDeclStyle];\n    const replacement = FUNCTION_STYLE_REPLACEMENT[this.applyFunctionStyle];\n\n    return strippedRecord.sub(regex, replacement).strip();\n  }\n\n  private write(data: string) {\n    this.lines.push(data);\n  }\n\n  private onLineEnd = (strippedRecord: Snippet, testRecord: Snippet) => {\n    // count open brackets for this.line continuation\n    this.openBrackets += testRecord.occurrences(/\\[/g);\n    this.openBrackets -= testRecord.occurrences(/\\]/g);\n    this.continueLine = strippedRecord.contains(/\\\\$/g);\n\n    this.line++;\n  };\n}\n"]}},"error":null,"hash":"4ce455c9e2874f685df6118797ee6188","cacheData":{"env":{}}}